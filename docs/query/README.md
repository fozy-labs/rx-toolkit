# RxQuery

RxQuery - система для управления запросами и кэшированием данных в RxToolkit. Она состоит из двух основных компонентов: **Resources** и **Operations**.

## Основные концепции

### Resources (Ресурсы)

Resources предназначены для реактивного кэширования повторяемых запросов. Они автоматически управляют состоянием загрузки, кэшируют результаты и обеспечивают эффективную инвалидацию данных.

**Ключевые особенности:**
- Автоматическое кэширование по аргументам запроса
- Поддержка AbortController для отмены запросов
- Реактивные обновления состояния
- Оптимистичные обновления

### Operations (Операции)

Operations представляют одноразовые операции или мутации. Они не кэшируются, но предоставляют состояние выполнения и могут связываться с ресурсами для их обновления.

**Ключевые особенности:**
- Отслеживание состояния выполнения
- Связывание с ресурсами для их обновления
- Поддержка оптимистичных обновлений
- Возможность блокировки связанных ресурсов

### Agents (Агенты)
Agents представляют собой интеллектуальные обертки над ресурсами (или операциями), 
которые обеспечивают более удобную работу с состояниями запросов для потребителей.

#### Основная проблема, которую решают агенты

Кэш ресурсов (или операций) содержит "сырые" состояния отдельных запросов, но потребителям нужна более высокоуровневая логика. 
Например:
- `isInitialLoading` должно быть true только при первой загрузке ресурса, но не при переключении между разными аргументами
- При смене аргументов запроса нужно показывать данные предыдущего запроса, пока загружается новый
- Состояние загрузки должно отражать контекст использования, а не просто состояние кэша

## API

### createResource

Создает новый ресурс для кэширования данных.

```typescript
const userResource = createResource<{ id: string }, User>({
  async queryFn(args, tools) {
    const response = await fetch(`/api/users/${args.id}`, {
      signal: tools.abortSignal
    });
    return response.json();
  },
  select: (data) => ({
    id: data.id,
    name: data.name,
    email: data.email
  })
});
```

**Параметры:**
- `queryFn(args, tools)` — функция выполнения запроса
- `select(data)` — опциональная функция трансформации данных

### createOperation

Создает новую операцию для выполнения мутаций.

```typescript
const updateUser = createOperation<
    { id: string; data: Partial<User> },
    User
>({
    async queryFn(args) {
        const response = await fetch(`/api/users/${args.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(args.data)
        });
        return response.json();
    },
    link(add) {
        add({
            resource: userResource,
            forwardArgs: (args) => ({ id: args.id }),
            optimisticUpdate(draft, args) {
                Object.assign(draft, args.data);
            },
        });
    }
});
```

**Параметры:**
- `queryFn(args)` — функция выполнения операции
- `link(ref)` — опциональная функция связывания с ресурсами


## Свойства Link
```typescript
/**
 * Настройки связи операции с ресурсом
 */
export type LinkOptions<D extends OperationDefinition, RD extends ResourceDefinition> = {
    /**
     * Целевой ресурс, с которым связывается операция
     * @required
     */
    resource: ResourceInstance<RD>;
    
    /**
     * Функция для получения аргументов ресурса из аргументов операции
     * Используется для определения какой именно элемент в кэше ресурса нужно обновить
     * @required
     */
    forwardArgs: (args: D["Args"]) => RD["Args"];
    
    /**
     * Флаг для инвалидации (очистки) кэша ресурса после выполнения операции
     * При true - кэш будет очищен и ресурс будет перезагружен при следующем обращении
     * @optional @default false
     */
    invalidate?: boolean;
    
    /**
     * Флаг для блокировки ресурса во время выполнения операции
     * При true - ресурс будет заблокирован и не сможет выполнять новые запросы
     * @optional @default false
     */
    lock?: boolean;
    
    /**
     * Функция для обновления кэша ресурса после успешного выполнения операции
     * Получает draft объект для мутации, аргументы операции и результат операции
     * @optional
     */
    update?: (tools: {
        /** Immer draft объект для мутации кэша ресурса */
        draft: RD["Data"];
        /** Аргументы, с которыми была вызвана операция */
        args: D["Args"];
        /** Результат выполнения операции */
        data: D["Data"];
    }) => void | RD["Data"] | Promise<RD["Data"]>;
    
    /**
     * Функция для оптимистичного обновления кэша ресурса ДО выполнения операции
     * Позволяет обновить UI немедленно, до получения ответа от сервера
     * @optional
     */
    optimisticUpdate?: (tools: {
        /** Immer draft объект для мутации кэша ресурса */
        draft: RD["Data"];
        /** Аргументы, с которыми была вызвана операция */
        args: D["Args"];
    }) => void | RD["Data"] | Promise<D["Data"]>;
    
    /**
     * Функция для создания нового элемента в кэше ресурса
     * Используется когда операция создает новую сущность, которую нужно добавить в кэш
     * @optional
     */
    create?: (tools: {
        /** Аргументы, с которыми была вызвана операция */
        args: D["Args"];
        /** Результат выполнения операции */
        data: D["Data"];
    }) => RD["Data"] | Promise<RD["Data"]>;
};
```


## Состояния запросов

Каждый ресурс и операция предоставляют следующие состояния:

```typescript
/**
 * Состояние запроса ресурса
 */
export type ResourceQueryState<D extends ResourceDefinition> = {
    /** Инициализирован ли хотя бы один запрос */
    isInitiated: boolean;
    /** Первая загрузка */
    isLoading: boolean;
    /** Завершен ли запрос */
    isDone: boolean;
    /** Успешно ли завершен последний запрос (false по умолчанию) */
    isSuccess: boolean;
    /** Произошла ли ошибка последнего запроса (false по умолчанию) */
    isError: boolean;
    /** Заблокирован ли ресурс */
    isLocked: boolean;
    /** Перезагружается ли ресурс */
    isReloading: boolean;
    /** Оригинал ошибки, если есть */
    error: unknown | undefined;
    /** Данные, полученные в результате запроса (или select данных) */
    data: D["Data"] | undefined;
    /** Аргументы запроса */
    args: D["Args"] | undefined; // TODO undefined - это костыль для сведения типов, его быть не должно
}

/**
 * Состояние выполнения операции
 */
export type OperationQueryState<D extends OperationDefinition> = {
    /** Выполняется ли операция в данный момент */
    isLoading: boolean;
    /** Завершена ли операция */
    isDone: boolean;
    /** Успешно ли завершена операция (false по умолчанию) */
    isSuccess: boolean;
    /** Произошла ли ошибка при выполнении операции (false по умолчанию) */
    isError: boolean;
    /** Оригинал ошибки, если есть */
    error: unknown | undefined;
    /** Результат выполнения операции */
    data: D["Data"] | undefined;
    /** Аргументы операции */
    args: D["Args"];
}

```
